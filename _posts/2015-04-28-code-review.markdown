Давай сразу по ходу буду комментировать код, этакое первое прочтение

public Kation(String newTitle, Integer newValence, String newResTitle) {
  setTitle(newTitle);
  setValence(newValence);
  resTitle = newResTitle;
}

Вот тут мне режет глаз, я не могу сформулировать правила, но обычно сеттеры в конструкторе не вызывают. Ну типа по хорошему, сеттер и геттер - это для внешнего мира. Вот если кому-то нужно снаружи знать, что у меня в этом поле, или хочет мне поставить новое значение, я делаю сеттер. А если я не хочу, чтобы обьект меняли, сделать его иммьютабл, я сделаю его конструктор приватным, уберу все сеттеры, и сделаю ему публичный фактори-метод, ну типа

public final class MySecret {
  private final Boolean doIBelieveInGod = Random.nextInt() % 2 == 0;
  private MySecret () {}

  public static MySecret tryToStealMySecret () {
    return new MySecret();
  }
} 

Кстати, это элемент супер-защищенного обьекта, который называется Singleton, почитай про этот паттерн, я его задаю на интервью, очень прикольная задачка, как сделать так, чтобы обьект в джава машине существовал в единственном экземпляре. 

Еще один момент такой про конструктор, я посмотрел, у тебя и дальше методы используют разные значения для параметров. 

public void setResAcidTitle(String newResAcidTitle) {
  resAcidTitle = newResAcidTitle;
}
 
То есть у тебя двойная система защиты :). Ты сначала используешь сеттер в конструкторе, а в нем самом у тебя переменные называются xxx и newXxx. Я вспоминаю, у меня было что-то похожее, когда начинал программировать. Очень страшно что-то сделать с полями класса и вообще внутри класса, вдруг что-то испорчу или сломаю. 

Вот тут мне очень помогает то, что все, что внутри класса, все моя крепость. Это то, что у меня есть, это то, что я делаю с классом, и я обычно знаю, что внутри моего класса. Java хороша тем, что в ней не бывает магии. Вот как ты написал, так оно и происходит (на самом деле, это конечно, не так, но с такими случаями ты врядли столкнешься в ближайшее время). Никто снаружи не придет и не дернет твой приватный метод, кроме тебя самой. 

Поэтому стоит не бояться своего кода и делать там ровно то, что нужно, и ничего больше. В твоем случае я бы написал так:

public Kation(String title, Integer valence, String resTitle) {
  this.title = title;
  this.valence = valence;
  this.resTitle = resTitle;
}

public void setResAcidTitle(String resAcidTitle) {
  this.resAcidTitle = resAcidTitle;
}

Конструкция this.xxx очень полезна, когда есть опасность, что может быть непонятно, что происходит, используй ее. Я присваиваю моему полю xxx то, что передали мне в параметре, неважно, как это называется. 

Хотя не могу отметить, что семантически все очень правильно написано было. Текущая переменная xxx присваивается новой переменной newXxx. Это все, конечно нюансы.

Но что это. Я замечаю, что у тебя в конструкторе не ставится поле recAcidTitle. Ошибка ли это, или продуманный замысел? Читаем код.

Пока непонятно. Я вот на что наткнулся, тоже такой адвансед тип, но мне кажется, тебе такие вещи должны быть интересны. Программировать на самом деле ты умеешь, тут уже вопрос нюансов профессии.

ArrayList<Kation> KationList = new ArrayList<Kation>();
readKationFromFile(KationList);
ArrayList<Anion> AnionList = new ArrayList<Anion>();
readAnionFromFile(AnionList);

Ты все правильно делаешь, это называется (не прямо это, но я бы так сказал) процедурным подходом. Как я понимаю, у тебя есть статическая функция, которая из известного тебе файла достает данные и запихивает их в созданный тобой список. Дешево и сердито. Я недавно сильно подсел на язык Scala (он работает в той же джава машине, но имеет другой синтакс, требует несколько другой подход к программированию. Правда, я считаю, что будущее Java в руках Scala) который является функциональным. 

Идея в том, что ты не пишешь указания компьютеру, как ему получить данные, а выстраиваешь систему функций (что-то дали на вход, что-то пришло на выход), которые потом берешь за один конец, и на выходе образовывается нужный тебе результат. 

Так же, непонятно из кода, откуда ты это читаешь. Я понимаю, что где-то дальше у тебя будет использоваться имя файла, но в данном месте это непонятно. А читаемость кода - очень важная вещь даже для самого себя. Я бы переделал этот код примерно так:

Chemistry chemistry = Chemistry.loadFromFile("i_dont_like_the_drugs_but_the_drugs_like_me.xml");
ArrayList<Kation> kationList = chemistry.getKations();
ArrayList<Anion> anionList = chemistry.getAnions();

И опять отмечу названия переменных с маленьких букв. С больших букв называют классы и интерфейсы, это как фамилии. А все обьекты - они с маленькой буквы. Нет двух классов Kation (могут быть, но это сложно сделать), но может быть сколько угодно обьектов с названием kationList, в каждой функции может быть такой.

Идем дальше. 

HashMap<Integer, Chem> hm = new HashMap<Integer, Chem>();
 
for (Integer i = 0; i < KationList.size(); i++) {
  Chem curChem = new Chem(KationList.get(i),AnionList.get(i));
  System.out.println(KationList.get(i).getTitle() + AnionList.get(i).getTitle());
  if (! hm.containsKey(curChem.hashCode())) {
    hm.put(curChem.hashCode(),curChem);
  }
}

Сначала по стилю. С какой-то там джавы (мы с тобой используем последнюю, 8-ю) уже не нужно писать шаблонные классы во второй части выражения, типа джава допрет сама (в Scala вообще можно почти везде типы не писать, она еще умнее). То есть можно писать так:

HashMap<Integer, Chem> hm = new HashMap<>();

По поводу больших и маленьких классов. Тут тебе переменная i нужна просто для индекса. Не заслужила чести быть большой. Большая нужна, если нам нужно проверять на null или когда ее куда-нибудь записывать надо, тут и маленькая сгодится.

for (Integer i = 0; i < KationList.size(); i++) {
for (int i = 0; i < KationList.size(); i++) {

Ну и самое важное, для чего я этот кусок привел. У тебя глаза об него не ломаются? :) Меня вот это обилие скобочек немного с ума сводит. Тут все правильно написано, но как-то тяжело читать. Смотри, у тебя в коде используется постоянно yyy.get(i).что_то_там. Почему бы не сделать дополнительные переменные и упростить код?

//Опять ставишь имплементацию, а не интерфейс типом переменной
//Map<> а не HashMap<>
Map<Integer, Chem> reactionResults = new HashMap<>();
 
for (int i = 0; i < kationList.size(); i++) {
  Kation kation = kationList.get(i);
  Anion anion = anionList.get(i);
  Chem chem = new Chem(kation,anion);
  System.out.println(kation.getTitle() + anion.getTitle());
  if (! reactionResults.containsKey(chem.hashCode())) {
    reactionResults.put(chem.hashCode(),chem);
  }
}

Еще я вижу, что мы тут вкрутили HashMap вообще не в тему. Она тут нафиг не нужна. Ты ее убери и мы потом в нужном месте ее применим. У тебя два ряда элементов сталкиваются, и по хорошему, на выходе будет тоже список, только уже результатов их взаимодействия.

Про функции чтения. Вот смотри, снова тот же прием применяю:

public static void readAnionFromFile(ArrayList<Anion> anList) {
 
  try {
   File myFile = new File("C:\\MSTest\\Ion\\anions.xml");
   DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
   DocumentBuilder db = dbf.newDocumentBuilder();
   Document doc = db.parse(myFile);
   doc.getDocumentElement().normalize();
   NodeList nodeLst = doc.getElementsByTagName("anion");
   for (int s = 0; s < nodeLst.getLength(); s++) {
    Node fstNode = nodeLst.item(s);
    if (fstNode.getNodeType() == Node.ELEMENT_NODE) {
     Element fstElmnt = (Element) fstNode;
 
     anList.add(new Anion(extractValue("title",fstElmnt),Integer.parseInt(extractValue("valence",fstElmnt)),
             extractValue("resAcidTitle",fstElmnt),extractValue("resSoltTitle",fstElmnt)));
    }
   }
  }
  catch (Exception e) {
   e.printStackTrace();
  }
}
 
public static void readKationFromFile (ArrayList<Kation> katList) {
               try {
   File myFile = new File("C:\\MSTest\\Ion\\kations.xml");
   DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
   DocumentBuilder db = dbf.newDocumentBuilder();
   Document doc = db.parse(myFile);
   doc.getDocumentElement().normalize();
   NodeList nodeLst = doc.getElementsByTagName("kation");
   for (int s = 0; s < nodeLst.getLength(); s++) {
    Node fstNode = nodeLst.item(s);
    if (fstNode.getNodeType() == Node.ELEMENT_NODE) {
    Element fstElmnt = (Element) fstNode;
    katList.add(new Kation(extractValue("title",fstElmnt),Integer.parseInt(extractValue("valence",fstElmnt)),extractValue("resTitle",fstElmnt)));
    }
   }
  }
  catch (Exception e) {
   e.printStackTrace();
  }
}


Отличий всего два (с ходу) - название файла и создание обьекта. Отчего бы не уменьшить число кода и не загружать сразу все в один прием? В том то и штука xml, что туда можно засунуть все и оно не будет пересекаться. Давай ты сделаешь один общий файл и будешь из него грузить и катионы и анионы, они же у тебя все наследуют класс Ion - ты можешь просто все в одной пачке ионов вернуть.

Тогда сталкивать можно вообще все со всем, мне лично было бы интересно на это посмотреть. Что с чем взаимодействует, а что нет, матрицу построить. Интересно было бы тебе сделать такое?


-------------

Вот и весь коде ревью. Я вот что тебе хочу сказать. мне очень нравится, что ты делаешь, не воспринимай текст выше, как критику, а как попытку передать те вещи, которые появляются с опытом и которые сразу так и не заметны.

Еще - не стесняйся задавать мне вопросы. На работе меня трудно зацепить, если я какой-то интересной задачей занялся, я весь в нее ухожу. Но твои вопросы меня очень радуют и я рад разливаться по древу, чтобы какой-то вопрос разьяснить. Не стесняйся писать, мне лучше получать от тебя много писем с маленькими вопросами, чем большой список. Я так могу сесть и написать абзац текста и кусочек кода, а с большими я долго собираюсь и не отвечаю очень не сразу. Меня очень радует возможность вещать и поучать, просто не всегда бывает момент, когда можно сесть и развернуто ответить, маленькие вопросы проще.

Я подумал, что нам лучше двигаться следующим образом. Я сделаю репозиторий в git c твоим кодом (заведи себе аккаунт на github.org) и добавлю в него проект Idea (поставь себе последнюю версию community edition) и сборку maven. К сожалению не вижу способа постепенно это все вводить, потому что maven сам плохо знаю, но без него никак в нашем деле уже. 

На майских думаю это сделать и напишу тебе письмо с затравками, уверен, ты разберешься, если проблемы, тут-же пиши, на простые вопросы отвечу тут-же.

У меня какая идея, чтобы тебе лучше во всем разобраться, мы с тобой сделаем трушный сервер, клиентскую часть я тебе напишу, будет у нас химическая лаборатория, где можно будет смотреть результаты разных реакций. У тебя будет возможность разобраться в том, как мы делаем то, что делаем на работе. Что думаешь? Интересно ли тебе, для меня это очень важно, я все боюсь, что вещаю тебе не то, что тебе на самом деле хочется научиться делать, не стесняйся, пиши.

 